'use strict';
// This is the entry point for the javascript tracer.

const Logger = require('./helpers/logger').Logger,
  Tracer = require('./core/tracer').Tracer,
  constants = require('./constants'),
  envVariables = process.env;

let lambdaTracer,
  lambdaLogger;

module.exports = {
  /** Options JSON:
  {
     controllerHostName: string,
     controllerPort: string/integer,
     accountAccessKey: string,
     accountName: string,
     applicationName: string,
     tierName: string,
     debug: boolean
  }**/
  init: function (options) {
    if (!options)
      options = {};

    lambdaLogger = Logger.getInstance();
    lambdaTracer = undefined;
    if (process.env.APPDYNAMICS_DISABLE_AGENT == true || process.env.APPDYNAMICS_DISABLE_AGENT === 'true') {
      lambdaLogger.info('Disabling the tracer');
      return;
    }

    if (options.debug || ((typeof envVariables.APPDYNAMICS_LOG_LEVEL === 'string') && ((envVariables.APPDYNAMICS_LOG_LEVEL).trim().toLowerCase() === 'debug')))
      lambdaLogger.setDebugMode();
    let accountAccessKey = options.accountAccessKey ? options.accountAccessKey : envVariables.APPDYNAMICS_AGENT_ACCOUNT_ACCESS_KEY,
      accountName = options.accountName ? options.accountName : envVariables.APPDYNAMICS_ACCOUNT_NAME,
      controllerHost = options.controllerHostName ? options.controllerHostName : envVariables.APPDYNAMICS_CONTROLLER_HOST,
      controllerPort = options.controllerPort ? parseInt(options.controllerPort, 10) : parseInt(envVariables.APPDYNAMICS_CONTROLLER_PORT, 10),
      applicationName = options.applicationName ? options.applicationName : envVariables.APPDYNAMICS_APPLICATION_NAME,
      tierName = options.tierName ? options.tierName : envVariables.APPDYNAMICS_TIER_NAME,
      serverlessApiEndpoint = options.serverlessApiEndpoint ? options.serverlessApiEndpoint : envVariables.APPDYNAMICS_SERVERLESS_API_ENDPOINT,
      proxyHost = options.proxyHost ? options.proxyHost : envVariables.APPDYNAMICS_HTTP_PROXY_HOST,
      proxyPort = options.proxyPort ? options.proxyPort : envVariables.APPDYNAMICS_HTTP_PROXY_PORT,
      proxyUser = options.proxyUser ? options.proxyUser : envVariables.APPDYNAMICS_HTTP_PROXY_USER,
      proxyPassword = options.proxyPassword ? options.proxyPassword : envVariables.APPDYNAMICS_HTTP_PROXY_PASSWORD,
      proxyPasswordFile = options.proxyPasswordFile ? options.proxyPasswordFile : envVariables.APPDYNAMICS_HTTP_PROXY_PASSWORD_FILE,
      proxyCertificateFile = options.certificateFile ? options.certificateFile : envVariables.APPDYNAMICS_HTTP_PROXY_SERVER_CERTIFICATE,
      version = constants.DEFAULT_AGENT_VERSION;

    if (!controllerHost || !controllerHost.length) {
      lambdaLogger.error('Appdynamics Controller Host is missing. Running the lambda without instrumentation.');
      return;
    }
    if (!controllerPort) {
      lambdaLogger.info('Appdynamics Controller Port is missing. Defaulting it to 443');
      controllerPort = 443;
    }
    if (!accountAccessKey || !accountAccessKey.length || accountAccessKey == 'undefined') {
      lambdaLogger.error('Appdynamics Controller Account Access Key is missing. Running the lambda without the instrumentation');
      return;
    }
    if (!accountName || !accountName.length) {
      lambdaLogger.error('Appdynamics Controller Account Name is missing. Running the lambda without instrumentation.');
      return;
    }
    if (!applicationName || !applicationName.length) {
      lambdaLogger.error('Application Name is missing. Running the lambda without instrumentation');
      return;
    }
    if (!serverlessApiEndpoint || !serverlessApiEndpoint.length) {
      lambdaLogger.error('AppDynamics Serverless Api endpoint is missing. Running the lambda without instrumentation.');
      return;
    }
    if (!tierName || !tierName.length) {
      lambdaLogger.info('Application Tier Name is missing. Will set it once the lambda function is known');
      tierName = '';
    }

    // Perform some env variable cleaning
    accountName = accountName.trim().toLowerCase();
    accountAccessKey = accountAccessKey.trim();
    applicationName = applicationName.trim();
    tierName = tierName.trim();
    controllerHost = cleanControllerHost(controllerHost);
    serverlessApiEndpoint = cleanServerlessApiEndpoint(serverlessApiEndpoint);
    if (proxyHost) proxyHost = proxyHost.trim();
    if (proxyPort) proxyPort = proxyPort.trim();
    if (proxyUser) proxyUser = proxyUser.trim();
    // Note: password is not trimmed as it could potentially contain whitespace
    if (proxyPasswordFile) proxyPasswordFile = proxyPasswordFile.trim();
    if (proxyCertificateFile) proxyCertificateFile = proxyCertificateFile.trim();



    lambdaTracer = new Tracer({
      controllerHost: controllerHost,
      controllerPort: controllerPort,
      accountName: accountName,
      accountAccessKey: accountAccessKey,
      tierName: tierName,
      applicationName: applicationName,
      serverlessApiEndpoint: serverlessApiEndpoint,
      version: version,
      proxyHost: proxyHost,
      proxyPort: proxyPort,
      proxyUser: proxyUser,
      proxyPassword: proxyPassword,
      proxyPasswordFile: proxyPasswordFile,
      proxyCertificateFile: proxyCertificateFile
    });
    return;
  },

  createTransaction: function () {
    if (lambdaTracer)
      return lambdaTracer.createTransaction();
    else
      lambdaLogger.error('Cannot create transaction. Tracer is not initialized yet');
  },

  stopTransaction: function () {
    if (lambdaTracer)
      lambdaTracer.stopTransaction();
    else
      lambdaLogger.error('Cannot stop transaction. Tracer is not initialized yet');
  },

  getCurrentTransaction: function () {
    if (lambdaTracer)
      return lambdaTracer.getCurrentTransaction();
    else
      lambdaLogger.error('Cannot get current transaction. Tracer is not initialized yet');
  },

  reportTransactionError: function (error) {
    if (lambdaTracer) {
      if (error)
        lambdaTracer.reportError(error);
      else
        lambdaLogger.error('Cannot report transaction error. Error is missing');
    } else
      lambdaLogger.error('Cannot report transaction error. Tracer is not initialized yet');
  },

  startExitCall: function (exitCallIInfo) {
    if (lambdaTracer)
      return lambdaTracer.startExitCall(exitCallIInfo);
    else
      lambdaLogger.error('Cannot star exit call. Tracer is not initialized yet.');
  },

  stopExitCall: function (exitCall) {
    if (lambdaTracer)
      return lambdaTracer.endExitCall(exitCall);
    else
      lambdaLogger.error('Cannot stop exit call. Tracer is not initialized yet.');
  },

  createCorrelationInfo: function (exitCall) {
    if (lambdaTracer)
      return lambdaTracer.createCorrelationInfo(exitCall);
    else
      lambdaLogger.error('Cannot create the correlation info for the exit call. Tracer is not initialized yet.');
  },

  reportExitCallError: function (exitCall, errorName, errorMessage) {
    if (lambdaTracer) {
      if (!exitCall)
        lambdaLogger.error('Cannot report exit call error. Exit call is missing.');
      else if (errorName && errorMessage)
        lambdaTracer.reportExitCallError(exitCall, errorName, errorMessage);
      else
        lambdaLogger.error('Cannot report exit call error. Both error name and error message should be passed.');
    } else
      lambdaLogger.error('Cannot report error to exit call. Tracer is not initialized yet.');
  },

  getEumMetadata: function (transaction) {
    if (lambdaTracer)
      return lambdaTracer.getEumMetadata(transaction);
    else
      lambdaLogger.error('Cannot fetch the eum metadata for the transaction. Tracer is not initialized yet.');
  },

  mainModule: function (appModule) {
    if (lambdaTracer)
      lambdaTracer.mainModule(appModule);
    else
      lambdaLogger.error('Cannot instrument lambda function. Tracer is not initialized yet');
  },

  getTracer: function () {
    return lambdaTracer;
  }
};

function cleanControllerHost(host) {
  const httpPrefix = "http://";
  const httpsPrefix = "https://";

  host = host.trim().toLowerCase();

  // Remove http/https prefix
  if (host.startsWith(httpPrefix)) {
    host = host.substring(httpPrefix.length);
  } else if (host.startsWith(httpsPrefix)) {
    host = host.substring(httpsPrefix.length);
  }

  // Remove trailing slash if it exists
  if (host.endsWith("/")) {
    host = host.substring(0, host.length - 1);
  }

  return host;
};

function cleanServerlessApiEndpoint(endpoint) {
  const httpPrefix = "http://";
  const httpsPrefix = "https://";

  // Note endpoint is not lowercased because it may include API versioning in the future
  // which could be case sensitive
  endpoint = endpoint.trim();

  // If url has http prefix change it to https
  if (endpoint.startsWith(httpPrefix)) {
    endpoint = endpoint.substring(httpPrefix.length);
    endpoint = httpsPrefix + endpoint;
  } else if (!endpoint.startsWith(httpsPrefix)) { // If url doesn't have https prefix add it
    endpoint = httpsPrefix + endpoint;
  }

  // Remove trailing slash if it exists
  if (endpoint.endsWith("/")) {
    endpoint = endpoint.substring(0, endpoint.length - 1);
  }

  return endpoint;
};