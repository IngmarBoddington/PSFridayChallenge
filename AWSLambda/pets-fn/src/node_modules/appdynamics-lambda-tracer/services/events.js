// Event service is responsible for the following things:
// 1. Keep an array of events at any instant of time.
// 2. Flush all the events in the array to a REST endpoint periodically.
var httpService = require('../helpers/httpService').HttpService,
  Logger = require('../helpers/logger').Logger,
  constants = require('../constants'),
  utility = require('../helpers/utility'),
  Q = require('q');

const flushTime = utility.getIntEnvironmentVariableOrDefault('APPDYNAMICS_EVENTS_FLUSH_PERIOD_MS', constants.FLUSH_REFRESH_TIME_IN_MS);

function EventsService(serverlessApiEndpoint, agent) {
  this.serverlessApiEndpoint = serverlessApiEndpoint;
  this.eventsArr = [];
  this.containsColdEvent = false;
  this.lastFlushed = undefined;
  this.agent = agent;
  this.logger = Logger.getInstance();
}

module.exports.EventsService = EventsService;

EventsService.prototype.getEventsApiEndpoint = function () {
  return this.serverlessApiEndpoint + constants.DEFAULT_EVENT_URL_PATH;
}

EventsService.prototype.addEvent = function (event) {
  // a cold start event is defined as having a bt_id of 0 and a non-empty entry point name and type.
  if (!event.bt_id && event.entry_point_name && event.entry_point_type) {
    this.containsColdEvent = true;
  }
  this.eventsArr.push(event);
}

EventsService.prototype.resetEvents = function () {
  this.eventsArr = [];
  this.containsColdEvent = false;
}

EventsService.prototype.printEvents = function () {
  var self = this;
  this.eventsArr.forEach(function (event) {
    self.logger.debug('[Event Service]', JSON.stringify(event));
  });
}

// Assumption:
// Flushing of events is always successful and we don't lose any events
// by reseting the events array after sending out the events downstream in 
// http post calls
EventsService.prototype.sendEventsDownstream = function () {
  var deferred = Q.defer();
  if (this.containsColdEvent || !this.lastFlushed || (Date.now() - this.lastFlushed >= flushTime)) {
    var self = this;
    var payload = this.eventsArr;
    this.logger.debug('[Event Service] Payload length is:', payload.length);
    if (payload.length) {
      this.printEvents();
      httpService.post(this.getEventsApiEndpoint(), null, payload, null)
        .then(function resolve(body) {
          if (body.error) {
            self.logger.error('[Event Service] Received error while sending the events downstream ' + body.error);
            deferred.reject(body.error);
          } else {
            self.logger.info('[Event Service] Successfully sent the events downstream');
            self.logger.debug('[Event Service] Response body is:', body);
            deferred.resolve(body);
          }
        }, function reject(err) {
          self.logger.error('[Event Service] Received error while sending the events downstream ' + err);
          deferred.reject(err);
        });
      this.lastFlushed = Date.now();
      this.resetEvents();
    }
  } else {
    process.nextTick(function () {
      deferred.resolve();
    })
  }
  return deferred.promise;
}