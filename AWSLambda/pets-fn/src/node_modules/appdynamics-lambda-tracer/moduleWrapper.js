/*
Copyright (c) AppDynamics, Inc., and its affiliates
2019
All Rights Reserved
 */
'use strict';

const wrapperHelper = require('./helpers/wrapperService');

function ModuleWrapper(agent, logger, eum) {
  this.agent = agent;
  this.logger = logger;
  this.eum = eum;
}
exports.ModuleWrapper = ModuleWrapper;

ModuleWrapper.prototype.attach = function (obj, agentConfigRequest) {
  let self = this;
  let instrumentedFns = [];

  if (obj.__appdynamicsProbeAttached__) return;
  obj.__appdynamicsProbeAttached__ = true;
  this.agent.on('destroy', function () {
    if (obj.__appdynamicsProbeAttached__) {
      delete obj.__appdynamicsProbeAttached__;
      instrumentedFns.forEach(function (fnName) {
        wrapperHelper.release(obj.exports[fnName]);
      });
    }
  });

  let exportKeyFns = [];
  let exportKeys = Object.keys(obj['exports']);
  for (let i = 0; i < exportKeys.length; i++) {
    if (typeof (obj['exports'][exportKeys[i]]) === 'function')
      exportKeyFns.push(exportKeys[i]);
  }
  // Put wrappers at before the lambda function execution
  // and after lambda function execution
  // Before:
  //      Perform all the agent configuration setup
  //      Set up the event service
  //      Start the transaction
  // After:
  //      Stop the transaction
  //      Stop any other open communication or clean up any objects
  //      created
  wrapperHelper.around(self.logger, obj['exports'], exportKeyFns, function (obj, args, locals) {
    // If it is a lambda function send out the agent config request.
    self.logger.info('[Lambda Probe] Intercepted the exports call of the module');
    if (args.length >= 2) {
      if (args[1] && args[1].awsRequestId
        && args[1].functionName && args[1].invokedFunctionArn
        && args[1].functionVersion) {
        self.agent.lambdaFnRunning = true;
        // Send out the agent config request
        agentConfigRequest.setFunctionDetails(args[1].functionName, args[1].functionVersion, args[1].invokedFunctionArn);
        agentConfigRequest.sendConfigRequest(Date.now());
        let transaction = self.agent.createTransaction(args[0], args[1]);
        locals.transaction = transaction;
        let lambdaEvent = args[0];
        locals.hasCallback = wrapperHelper.callbackPromiseChain(self.logger, args, -1, function (obj, args) {
          let flushEventsPromise;
          if (!locals.promiseBasedLambda) {
            self.logger.debug('[Lambda Probe] In callback');
            if (locals.transaction) {
              //Check if the callback has an error
              let callbackError = wrapperHelper.getErrorObject(args);
              if (callbackError) {
                self.logger.debug('[Lambda Probe] BT Error Occurred.');
                self.agent.reportError(callbackError);
              }

              self.logger.debug('[Lambda Probe] Transaction created:', locals.transaction);
              flushEventsPromise = self.agent.stopTransaction();
              // Add EUM headers to the response if:
              // 1. APPDYNAMICS_ENABLE_EUM environment variable is set
              // 2. Transaction is originating transaction
              // 3. Lambda invocation is API gateway call.
              // 4. Lambda invocation doesn't return an errror
              if (self.eum && self.eum.enabled && !locals.transaction.corrHeader && isApiGatewayCall(lambdaEvent) && !callbackError) {
                if (!args[1])
                  args[1] = {};
                if (Object.prototype.toString.call(args[1]) === '[object Object]')
                  getEumCookie(lambdaEvent, self.eum, locals.transaction, args[1], self.logger);
              }
            } else {
              self.logger.debug("No transaction has started. Will not report BTs or errors.");
            }
            self.agent.lambdaFnRunning = false;
            self.agent.emit('lambdaExecutionComplete');
            return flushEventsPromise;
          }
        });
      }
    }
  }, function (obj, args, ret, locals) {
    // The following condition will be satisfied for either async lambdas (or) 
    // when a non-async lambda fails before its callback is invoked
    if (ret && (ret.__appdynamicsIsPromiseResult__ || locals.hasCallback)) {

      // If stopTransaction returns a promise then the around() wrapper will ensure that the 
      // pending downstream events are flushed.
      let flushEventsPromise;

      if (ret.__appdynamicsIsPromiseResult__) {
        self.logger.debug('[Lambda Probe] In promise');
        locals.promiseBasedLambda = true;
      }

      if (locals.transaction) {
        let lambdaEvent = args[0];

        if (ret.error) {
          self.logger.debug('[Lambda Probe] BT Error Occurred.');
          self.agent.reportError(ret.error);
        }
        self.logger.debug('[Lambda Probe] Transaction created:', locals.transaction);
        flushEventsPromise = self.agent.stopTransaction();
        // Add EUM headers to the response if:
        // 1. APPDYNAMICS_ENABLE_EUM environment variable is set
        // 2. Transaction is originating transaction
        // 3. Lambda invocation is API gateway call.
        // 4. Lambda invocation doesn't return an errror
        if (self.eum && self.eum.enabled && !locals.transaction.corrHeader && isApiGatewayCall(lambdaEvent) && !ret.error) {
          if (!ret.data)
            ret.data = {};
          if (Object.prototype.toString.call(ret.data) === '[object Object]')
            getEumCookie(lambdaEvent, self.eum, locals.transaction, ret.data, self.logger);
        }
      }
      self.agent.lambdaFnRunning = false;
      self.agent.emit('lambdaExecutionComplete');
      //Note: locals.promiseBasedLambda is used instead of locals.hasCallback
      //      because from testing it appears that locals.hasCallback is set to true
      //      even for promise based handlers. This is because the lambda runtime
      //      passes the callback object regardless of the type of handler (async or non-async)
      if (!locals.promiseBasedLambda && ret.error && ret.isLambdaError) {
        // If callback based lambda threw an error then we need to rethrow it
        if (flushEventsPromise) {
          // Ensure events flush before throwing error
          return flushEventsPromise.then(function () {
            return Promise.reject(ret.error);
          }).catch(function (err) {
            return Promise.reject(ret.error);
          });
        } else {
          throw ret.error;
        }
      }
      return flushEventsPromise;
    }
  });
};

// Lambda invocation is API Gateway call if the event's request context has "httpMethod", "resourcePath"
// and "resourceId"
// Example event is documented here: https://docs.aws.amazon.com/lambda/latest/dg/with-on-demand-https.html
function isApiGatewayCall(lambdaEvent) {
  if (lambdaEvent && lambdaEvent['requestContext'] && lambdaEvent['requestContext']['httpMethod'] &&
    lambdaEvent['requestContext']['resourcePath'] && lambdaEvent['requestContext']['resourceId'])
    return true;
  return false;
}

function getEumCookie(lambdaEvent, eum, transaction, lambdaResponse, logger) {
  let eumCookie = eum.newEumCookie(transaction, lambdaEvent['headers'], lambdaResponse);
  eumCookie.build();
  logger.debug('[Lambda Probe] Response headers are:', lambdaResponse['headers'], 'and multivalueheaders are:', lambdaResponse['multiValueHeaders']);
}