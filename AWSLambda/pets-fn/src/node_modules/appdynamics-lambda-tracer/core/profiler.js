'use strict';

const Transaction = require('../transaction/transaction').Transaction;
const ExitCall = require('../exitCall/exitCall').ExitCall;
const BTEvent = require('../events/btEvent').BTEvent;
const ErrorEvent = require('../events/errorEvent').ErrorEvent;
const Logger = require('../helpers/logger').Logger;
const CorrelationHeader = require('../correlation/correlationHeader').CorrelationHeader;

const BackendRegistrationEvent = require('../events/registrationBackendEvent').BackendRegistrationEvent;
const ExitCallEvent = require('../events/exitCallEvent').ExitCallEvent;
const EUM = require('../eum/eum').Eum;
const constants = require('../constants');

// This is going to be the glue between transaction and exit calls.
function Profiler(agent, eventService, exitCallRegistry, agentConfigRequest, agentConfigResponse) {
  this.agent = agent;
  this.eventService = eventService;
  this.exitCallRegistry = exitCallRegistry;
  this.agentConfigRequest = agentConfigRequest;
  this.agentConfigResponse = agentConfigResponse;
  this.currentTransaction = null;
  this.resetCurrentTransaction();
  this.logger = Logger.getInstance();
}

exports.Profiler = Profiler;

Profiler.prototype.startTransaction = function (event, context) {
  let self = this;
  if (self.hasTransactionStarted()) {
    self.logger.info('Transaction already started');
    return self.getCurrentTransaction();
  }

  self.logger.debug('Starting new transaction.');
  let currentTransaction = new Transaction({
    name: getDefaultTransactionName(self.agentConfigRequest),
    stopped: false
  });
  self.setCurrentTransaction(currentTransaction);
  self.agent.emit('transactionStarted', {
    txn: currentTransaction,
    lambdaEvent: event,
    lambdaContext: context
  });
  return currentTransaction;
};

Profiler.prototype.hasTransactionStarted = function () {
  return (this.getCurrentTransaction() && !this.getCurrentTransaction().stopped) ? true : false;
}

Profiler.prototype.stopTransaction = function () {
  let self = this;
  if (!self.hasTransactionStarted()) {
    self.logger.info('Transaction already stopped');
    return;
  }

  let currentTransaction = self.getCurrentTransaction();
  if (currentTransaction != null) {
    currentTransaction.stopped = true;
    let endTimeInMs = Date.now();
    currentTransaction.ms = endTimeInMs;
    self.logger.info("Stopping business transaction: " + currentTransaction.name);

    let args = {
      bt_id: currentTransaction.registrationId,
      transaction_guid: currentTransaction.guid,
      start_time: currentTransaction.ts,
      end_time: endTimeInMs,
      caller_chain: currentTransaction.callerChain,
      version: constants.DEFAULT_AGENT_VERSION
    };

    if (!args.bt_id) {
      args.entry_point_type = "NODEJS_WEB";
      args.entry_point_name = currentTransaction.name;
    }

    let btEvent = new BTEvent(args);

    self.eventService.addEvent(btEvent);
    self.resetCurrentTransaction();
  }

  return self.eventService.sendEventsDownstream(); //Flush the events
};

Profiler.prototype.reportError = function (error) {
  let self = this;
  let currentTxn = self.getCurrentTransaction();

  if (self.hasTransactionStarted()) {
    let endTimeInMs = Date.now();
    let errorName, errorMessage;

    if (typeof (error) === 'object') {
      errorName = error.name;
      errorMessage = error.message;
    } else {
      errorName = "Error";
      errorMessage = error;
    }

    let args = {
      bt_id: currentTxn.registrationId,
      backend_id: 0,
      caller_chain: currentTxn.callerChain,
      error_name: errorName,
      error_message: errorMessage,
      version: constants.DEFAULT_AGENT_VERSION,
      http_status_code: 0,
      start_time: currentTxn.ts,
      end_time: endTimeInMs,
      transaction_guid: currentTxn.guid
    };

    if (!args.bt_id) {
      args.entry_point_name = currentTxn.name;
      args.entry_point_type = "NODEJS_WEB";
    }

    let errorEvent = new ErrorEvent(args);

    self.logger.debug('Reporting transaction error with name="' + errorName + '" & message="' + errorMessage + '"');
    self.eventService.addEvent(errorEvent);
    return;
  }

  self.logger.debug('BT error will not be reported as the transaction has not started.');
};

Profiler.prototype.reportExitCallError = function (errorName, errorMessage, backendId, httpStatusCode) {
  let self = this;
  if (!self.hasTransactionStarted()) {
    self.logger.debug('Exit call error will not be reported as the transaction has not started.');
    return;
  }

  if (backendId == undefined) {
    self.logger.debug('Exit call error will not be reported as the backend is not registered yet.');
    return;
  }

  let currentTxn = self.getCurrentTransaction();
  let endTimeInMs = Date.now();
  let errorEvent = new ErrorEvent({
    bt_id: currentTxn.registrationId,
    backend_id: backendId,
    caller_chain: currentTxn.callerChain,
    error_name: (errorName && errorName.length) ? errorName : '',
    error_message: (errorMessage && errorMessage.length) ? errorMessage : '',
    version: constants.DEFAULT_AGENT_VERSION,
    http_status_code: httpStatusCode != undefined ? httpStatusCode : 0,
    start_time: currentTxn.ts,
    end_time: endTimeInMs,
    transaction_guid: currentTxn.guid
  });
  self.logger.debug('Reporting exit call error for backend', backendId, '. Error name="', errorName, '" & Error message="', errorMessage, '"');
  self.eventService.addEvent(errorEvent);
  return;
}

Profiler.prototype.resetCurrentTransaction = function () {
  this.currentTransaction = null;
}

Profiler.prototype.setCurrentTransaction = function (transaction) {
  if (transaction)
    this.currentTransaction = transaction;
}

Profiler.prototype.getCurrentTransaction = function () {
  return this.currentTransaction;
}

Profiler.prototype.startExitCall = function (exitCallInfo) {
  if (!Profiler.validateExitCallInfo(this.logger, exitCallInfo))
    return;
  let self = this;
  if (!self.hasTransactionStarted() || !self.getCurrentTransaction()) {
    self.logger.info('No running transaction. Ignoring the exit call');
    exitCallInfo.txnGuid = undefined;
    return;
  }
  let newExitCall = self.createExitCall(exitCallInfo);
  if (!newExitCall) {
    self.logger.info('No matching backend is found for the exit call info provided', exitCallInfo);
    return;
  } else {
    self.agent.emit('exitCallStarted', newExitCall);
  }
  return newExitCall;
}

Profiler.prototype.createExitCall = function (exitCallInfo) {
  let backendInfoId = this.exitCallRegistry.getBackendId(exitCallInfo.exitType, exitCallInfo.exitSubType, exitCallInfo.identifyingProperties);
  // Exit call's backend info is not registered
  if (!backendInfoId) {
    this.logger.debug('Sending Backend Registration event for exit call info:', exitCallInfo);
    let backendRegistrationEvent = new BackendRegistrationEvent(exitCallInfo.exitType, exitCallInfo.exitSubType, exitCallInfo.identifyingProperties, constants.DEFAULT_AGENT_VERSION);
    this.eventService.addEvent(backendRegistrationEvent);
    return;
  }

  // If current transaction does not have a bt_id don't create an exit call event since cold start scenario
  // is still not yet supported for exit calls.
  if (!this.getCurrentTransaction().registrationId) {
    this.logger.debug('Current transaction does not have a bt_id, will not create exit call');
    return;
  }

  // Placeholder: Exit call's backend info is registered. Create the exit call object here with all the necessary information populated
  this.logger.debug('Exit Call: ' + JSON.stringify(exitCallInfo) + ' is already registered with the controller.');
  let currentExitCall = new ExitCall({ exitType: exitCallInfo.exitType, exitSubType: exitCallInfo.exitSubType, identifyingProperties: exitCallInfo.identifyingProperties, backendId: backendInfoId },
    this.getCurrentTransaction().guid, this.getCurrentTransaction().registrationId, this.getCurrentTransaction());
  this.getCurrentTransaction().exitCallCounter++;
  currentExitCall.sequenceInfo = this.getCurrentTransaction().exitCallCounter;
  return currentExitCall;
}

Profiler.prototype.endExitCall = function (exitCall) {
  if (!ExitCall.validate(exitCall))
    return;

  exitCall.endTimeInMs = Date.now();
  let exitCallEvent = new ExitCallEvent(exitCall.btId, exitCall.txnGuid, exitCall.startTimeInMs,
    exitCall.endTimeInMs, 'REGISTERED', exitCall.backendId, exitCall.txn.callerChain, constants.DEFAULT_AGENT_VERSION);

  this.eventService.addEvent(exitCallEvent);
  if (!this.hasTransactionStarted() || (exitCall.txnGuid != this.getCurrentTransaction().guid))
    this.eventService.sendEventsDownstream();
}

Profiler.prototype.getCorrelationHeaderValue = function (exitCall) {
  if (!ExitCall.validate(exitCall)) {
    let corrHeader = new CorrelationHeader(this.agentConfigResponse.getApplicationId(),
      this.agentConfigResponse.getAccountGuid(),
      this.agentConfigResponse.getTierId(),
      this.agentConfigResponse.getControllerGuid());
    corrHeader.generateNoTxnDetectHeader();
    return corrHeader.getStringHeader();
  }
  let corrHeader = new CorrelationHeader(this.agentConfigResponse.getApplicationId(),
    this.agentConfigResponse.getAccountGuid(),
    this.agentConfigResponse.getTierId(),
    this.agentConfigResponse.getControllerGuid());
  corrHeader.generateCorrelationHeader(exitCall.txn, exitCall);
  return corrHeader.getStringHeader();
}

// This method returns the eum metadata, assuming the
// call is ajax call
Profiler.prototype.getEumMetadata = function (transaction, eum) {
  if (!transaction) {
    this.logger.error('Cannot get the eum metadata as transaction is missing.');
    return;
  }
  if (!(eum instanceof EUM)) {
    this.logger.error('Cannot get the eum metadata as instance of eum passed is not correct.');
    return;
  }

  let headersContainer = {};
  let eumCookie = eum.newEumCookie(transaction, null, headersContainer);
  eumCookie.setAjaxCall();
  eumCookie.build();
  return headersContainer.headers;
}

function getDefaultTransactionName(agentConfigRequest) {
  return agentConfigRequest.functionName + '_' + agentConfigRequest.functionVersion;
}

Profiler.validateExitCallInfo = function (logger, exitCallInfo) {
  if (!exitCallInfo) {
    logger.error('Exit call info failed validation. Exit call info is missing');
    return false;
  }
  if (!exitCallInfo.exitType) {
    logger.error('Exit call info failed validation. Exit type is missing');
    return false;
  } else if (!exitCallInfo.exitSubType) {
    logger.error('Exit call info failed validation. Exit sub type is missing');
    return false;
  } else if (!exitCallInfo.identifyingProperties) {
    logger.error('Exit call info failed validation. Identifying properties is missing');
    return false;
  }
  return true;
}