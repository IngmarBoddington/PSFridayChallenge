/*
Copyright (c) AppDynamics, Inc., and its affiliates
2015
All Rights Reserved
 */
'use strict';

var Logger = require('../helpers/logger').Logger;
var constants = require('../constants');

function CorrelationHeader(appId, accountGuid, tierId, controllerGuid) {
  this.appId = appId;
  this.accountGuid = accountGuid;
  this.tierId = tierId;
  this.controllerGuid = controllerGuid;
  this.subHeaders = {};
  this.crossAppCorrelation = false;
  this.txDetect = true;
  this.logger = Logger.getInstance();
}
exports.CorrelationHeader = CorrelationHeader;


CorrelationHeader.prototype.addSubHeader = function (name, value) {
  var self = this;

  self.subHeaders[name] = value;
};

CorrelationHeader.prototype.getSubHeader = function (name, defaultValue) {
  var self = this;

  var value = self.subHeaders[name];

  if (value === undefined && defaultValue !== undefined) {
    return defaultValue;
  }

  return value;
};

CorrelationHeader.prototype.getStringSubHeader = function (name) {
  var self = this;

  var value = self.subHeaders[name];
  if (value) {
    if (Array.isArray(value)) {
      return value.join(',');
    }
    if (typeof (value) === 'boolean') {
      return value.toString();
    }
    else {
      return value;
    }
  }
  else {
    return undefined;
  }
};

CorrelationHeader.prototype.getStringHeader = function () {
  var self = this;

  var pairs = [];

  for (var name in self.subHeaders) {
    pairs.push(name + '=' + self.getStringSubHeader(name));
  }

  return pairs.join('*');
};

CorrelationHeader.prototype.parseHeaderString = function (headerString) {
  var self = this;
  // sanitize header based on CORE-20346
  var headerStringParts = headerString.split(', ');
  headerString = headerStringParts[headerStringParts.length - 1];
  //

  var pairsMap = {};
  var pairs = headerString.split('*');
  pairs.forEach(function (pairString) {
    var pair = pairString.split('=');

    if (pair.length == 2 && pair[1] !== undefined) {
      pairsMap[pair[0]] = pair[1];
    }
  });


  // value lists
  [constants.COMPONENT_ID_FROM,
  constants.COMPONENT_ID_TO,
  constants.EXIT_CALL_TYPE_ORDER,
  constants.EXIT_CALL_SUBTYPE_KEY,
  constants.THREAD_CALL_CHAIN_FOR_OUT_OF_PROCESS].forEach(function (name) {
    var value = pairsMap[name];
    if (value !== undefined) {
      self.addSubHeader(name, value.split(','));
      delete pairsMap[name];
    }
  });


  // boolean values
  [constants.DONOTRESOLVE,
  constants.SNAPSHOT_ENABLE,
  constants.DISABLE_TRANSACTION_DETECTION,
  constants.FORCE_HOTSPOT_COLLECT,
  constants.HOTSPOT_COLLECTING_CPU_TIME,
  constants.DEV_MODE_ENABLED,
  constants.ASYNC_CALL,
  constants.DEBUG_ENABLED].forEach(function (name) {
    var value = pairsMap[name];
    if (value !== undefined) {
      self.addSubHeader(name, value.toLowerCase() === 'true');
      delete pairsMap[name];
    }
  });


  // string values
  for (var name in pairsMap) {
    self.addSubHeader(name, pairsMap[name]);
  }
};

CorrelationHeader.prototype.disabledTransaction = function () {
  return !this.txDetect;
}

CorrelationHeader.prototype.isCrossApp = function () {
  var accountGuid = this.getSubHeader(constants.ACCOUNT_GUID);
  var appId = this.getSubHeader(constants.APP_ID);
  this.logger.debug('Correlation header from app', appId, 'to app', this.appId);
  this.logger.debug('Correlation header from account', accountGuid, 'to account', this.accountGuid);
  if ((appId && appId != this.appId) || (accountGuid && accountGuid != this.accountGuid)) {
    this.crossAppCorrelation = true;
    return true;
  }
  this.crossAppCorrelation = false;
  return false;
}

CorrelationHeader.prototype.validateHeaderString = function (headerString) {
  var self = this;

  // parse string header to subheader pairs
  self.parseHeaderString(headerString);

  // disable transaction detection if subheader is set
  if (self.getSubHeader(constants.DISABLE_TRANSACTION_DETECTION)) {
    self.txDetect = false;
    self.logger.debug("CorrelationHeader.parse: transaction disabled from the originating tier, not processing");
    return false;
  }

  var cidFrom = self.getSubHeader(constants.COMPONENT_ID_FROM) || [];
  var cidTo = self.getSubHeader(constants.COMPONENT_ID_TO) || [];
  var eTypeOrder = self.getSubHeader(constants.EXIT_CALL_TYPE_ORDER) || [];
  var eSubType = self.getSubHeader(constants.EXIT_CALL_SUBTYPE_KEY) || [];

  if (cidFrom.length != cidTo.length || cidFrom.length != eTypeOrder.length) {
    self.logger.error("Malformed caller chain");
    return false;
  }

  if (eSubType.length === 0 && eTypeOrder.length > 0) {
    eSubType = eTypeOrder.slice(0);
  }

  if (eTypeOrder.length != eSubType.length) {
    self.logger.error("Malformed header exitTypes", eTypeOrder, ', exitSubTypes', eSubType);
    return false;
  }

  // read caller chain
  self.callerChain = self.readCallerChain(cidFrom, cidTo, eTypeOrder, eSubType);
  if (CorrelationHeader.isCallerChainTooLong(self.callerChain, self.logger))
    return false;

  return true;
}

CorrelationHeader.isCallerChainTooLong = function (callerChain, logger) {
  var len = 0;
  callerChain.forEach(function (component) {
    len += 30 + component[constants.COMPONENT_ID_FROM].length
      + (component[constants.EXIT_CALL_TYPE_ORDER] ? component[constants.EXIT_CALL_TYPE_ORDER].length : 0)
      + (component[constants.COMPONENT_ID_TO] ? component[constants.COMPONENT_ID_TO].length : 0)
      + (component['latestThreadAddId'] ? component['latestThreadAddId'].length : 0)
  })
  logger.debug('Component Links', callerChain, 'length is', len);
  return (len + constants.METRIC_NAME_LENGTH) > constants.MAX_METRIC_LENGTH;
}

CorrelationHeader.prototype.readCallerChain = function (cidFromArr, cidToArr, eTypeOrderArr, eSubTypeArr) {
  var self = this;
  var exitCallPositionVsLatestThreadAddId;
  var tcops = self.getSubHeader(constants.THREAD_CALL_CHAIN_FOR_OUT_OF_PROCESS);
  if (tcops && tcops.length) {
    exitCallPositionVsLatestThreadAddId = {};
    tcops.forEach(function (tcop) {
      /**
       * Each threadChain is of the format $exit_call_position:$thread_add_id(s)
       *
       * Note, the portion following the ':' may be one or more ADD IDs, in case an upstream agent sending the
       * header was older than the one receiving
      */
      var posAndIds = tcop.split(':');
      var exitCallPosition = posAndIds[0];
      var threadAddIdString = posAndIds[1];
      // parse based on the old encoding, which should cover both old agents and the new
      var ids = threadAddIdString.split('-');
      if (Number.isInteger(parseInt(exitCallPosition, 10)))
        exitCallPositionVsLatestThreadAddId[parseInt(exitCallPosition, 10)] = ids[ids.length - 1];
    })
  }

  // parse components
  var componentLinks = []; // needed for size
  var componentLink;
  for (var i = 0; i < cidFromArr.length; i++) {
    componentLink = {};
    componentLink[constants.COMPONENT_ID_FROM] = cidFromArr[i];
    componentLink[constants.COMPONENT_ID_TO] = cidToArr[i];
    componentLink[constants.EXIT_CALL_TYPE_ORDER] = eTypeOrderArr[i];
    componentLink[constants.EXIT_CALL_SUBTYPE_KEY] = eSubTypeArr[i];
    if (exitCallPositionVsLatestThreadAddId && exitCallPositionVsLatestThreadAddId[i + 1]) {
      componentLink['latestThreadAddId'] = exitCallPositionVsLatestThreadAddId[i + 1];
    }
    componentLinks.push(componentLink);
  }
  self.logger.debug('Caller chain read is:', componentLinks);
  return componentLinks;
}

CorrelationHeader.prototype.getCallerChain = function () {
  var self = this;
  var callerChainMap = [];
  if (self.getSubHeader(constants.APP_ID))
    callerChainMap.push(constants.APP_ID + '=' + (self.getSubHeader(constants.APP_ID)).toString());
  if (self.getSubHeader(constants.ACCOUNT_GUID))
    callerChainMap.push(constants.ACCOUNT_GUID + '=' + (self.getSubHeader(constants.ACCOUNT_GUID)).toString());
  callerChainMap.push(constants.DONOTRESOLVE + '=' + (Boolean(self.getSubHeader(constants.DONOTRESOLVE))).toString());
  if (self.getSubHeader(constants.COMPONENT_ID_FROM))
    callerChainMap.push(constants.COMPONENT_ID_FROM + '=' + (self.getSubHeader(constants.COMPONENT_ID_FROM)).toString());
  if (self.getSubHeader(constants.COMPONENT_ID_TO))
    callerChainMap.push(constants.COMPONENT_ID_TO + '=' + (self.getSubHeader(constants.COMPONENT_ID_TO)).toString());
  if (self.getSubHeader(constants.EXIT_CALL_TYPE_ORDER))
    callerChainMap.push(constants.EXIT_CALL_TYPE_ORDER + '=' + (self.getSubHeader(constants.EXIT_CALL_TYPE_ORDER)).toString());
  if (self.getSubHeader(constants.EXIT_CALL_SUBTYPE_KEY))
    callerChainMap.push(constants.EXIT_CALL_SUBTYPE_KEY + '=' + (self.getSubHeader(constants.EXIT_CALL_SUBTYPE_KEY)).toString());
  if (self.getSubHeader(constants.UNRESOLVED_EXIT_ID))
    callerChainMap.push(constants.UNRESOLVED_EXIT_ID + '=' + (self.getSubHeader(constants.UNRESOLVED_EXIT_ID)).toString());
  return callerChainMap.join('*');
}

CorrelationHeader.prototype.makeContinuingTransaction = function (transaction) {
  var self = this;

  var btId = self.getSubHeader(constants.BT_ID);

  if (btId) {
    transaction.registrationId = parseInt(btId, 10);
  } else {
    self.logger.error("CorrelationHeader.makeContinuingTransaction: invalid correlation header, did not find BT id or name");
    return false;
  }

  transaction.guid = self.getSubHeader(constants.REQUEST_GUID);
  transaction.skewAdjustedStartWallTime = self.getSubHeader(constants.TIMESTAMP);
  transaction.callerChain = self.getCallerChain();
  return true;
};

CorrelationHeader.prototype.generateNoTxnDetectHeader = function () {
  this.addSubHeader(constants.DISABLE_TRANSACTION_DETECTION, true);
}

CorrelationHeader.prototype.generateCorrelationHeader = function (transaction, exitCall) {
  var self = this;

  // if the upstream tier has sent a notxdetect=true, then we should
  // also pass it on to all downstream tiers
  if (transaction.corrHeader && transaction.corrHeader.txDetect === false) {
    self.addSubHeader(constants.DISABLE_TRANSACTION_DETECTION, true);
  }

  if (transaction.ignore) {
    return;
  }

  var incomingHeader;
  if (transaction.corrHeader) {
    if (!transaction.corrHeader.crossAppCorrelation) {
      incomingHeader = transaction.corrHeader;
    }
  }

  // Note: registrationID is equivalent to backendId
  //       componentID is equivalent to //TODO

  // if backend call is not registered
  if (!exitCall.backendId) {
    self.addSubHeader(constants.DISABLE_TRANSACTION_DETECTION, true);

    if (incomingHeader && incomingHeader.getSubHeader(constants.DEBUG_ENABLED)) {
      self.addSubHeader(constants.DEBUG_ENABLED, true);
    }

    self.logger.debug("Disabling correlation header generated: ", self.getStringHeader());
    return;
  }


  // add app id subheader
  self.addSubHeader(constants.ACCOUNT_GUID, self.accountGuid);
  self.addSubHeader(constants.CONTROLLER_GUID, self.controllerGuid);
  self.addSubHeader(constants.APP_ID, self.appId);


  // add BT related subheaders
  if (transaction.registrationId) {
    self.addSubHeader(constants.BT_ID, transaction.registrationId);
  }

  // add request guid subheader
  self.addSubHeader(constants.REQUEST_GUID, transaction.guid);
  if (transaction.skewAdjustedStartWallTime) {
    self.addSubHeader(constants.TIMESTAMP, transaction.skewAdjustedStartWallTime);
  }

  // add debug subheader
  if (incomingHeader && incomingHeader.getSubHeader(constants.DEBUG_ENABLED))
    self.addSubHeader(constants.DEBUG_ENABLED, true);

  // add snapshot enable subheader
  if (incomingHeader && incomingHeader.getSubHeader(constants.SNAPSHOT_ENABLE))
    self.addSubHeader(constants.SNAPSHOT_ENABLE, true);

  // add devmodeenabled subbheader
  if (incomingHeader && incomingHeader.getSubHeader(constants.DEV_MODE_ENABLED))
    self.addSubHeader(constants.DEV_MODE_ENABLED, true);

  // add hotspotenable subheader
  if (incomingHeader && incomingHeader.getSubHeader(constants.FORCE_HOTSPOT_COLLECT))
    self.addSubHeader(constants.FORCE_HOTSPOT_COLLECT, true);

  // add hotspotcpu subheader
  if (incomingHeader && incomingHeader.getSubHeader(constants.HOTSPOT_COLLECTING_CPU_TIME))
    self.addSubHeader(constants.HOTSPOT_COLLECTING_CPU_TIME, true);

  if (incomingHeader && incomingHeader.getSubHeader(constants.ASYNC_CALL))
    self.addSubHeader(constants.ASYNC_CALL, true);

  if (exitCall.exitComponent)
    self.addSubHeader(constants.UNRESOLVED_EXIT_ID, exitCall.exitComponent.getBackendId());

  // add exit guid subheader
  if (incomingHeader && incomingHeader.getSubHeader(constants.EXIT_POINT_GUID)) {
    var incomingSequenceInfo = incomingHeader.getSubHeader(constants.EXIT_POINT_GUID);
    self.addSubHeader(constants.EXIT_POINT_GUID, incomingSequenceInfo + "|" + exitCall.sequenceInfo);
  } else
    self.addSubHeader(constants.EXIT_POINT_GUID, exitCall.sequenceInfo);

  // add component link subheaders
  var compFrom = [];
  var compTo = [];
  var exitOrder = [];
  var exitSubType = [];
  var exitCallPositionVsLatestThreadAddId;

  if (incomingHeader) {
    compFrom = incomingHeader.getSubHeader(constants.COMPONENT_ID_FROM) || [];
    compTo = incomingHeader.getSubHeader(constants.COMPONENT_ID_TO) || [];
    exitOrder = incomingHeader.getSubHeader(constants.EXIT_CALL_TYPE_ORDER) || [];
    exitSubType = incomingHeader.getSubHeader(constants.EXIT_CALL_SUBTYPE_KEY) || [];
    exitCallPositionVsLatestThreadAddId = incomingHeader.getSubHeader(constants.THREAD_CALL_CHAIN_FOR_OUT_OF_PROCESS);
  }

  compFrom.push(self.tierId);
  if (exitCall.exitComponent)
    compTo.push(exitCall.exitComponent.getExitComponentAsStr());
  exitOrder.push(exitCall.exitType);
  exitSubType.push(exitCall.exitSubType);

  self.addSubHeader(constants.COMPONENT_ID_FROM, compFrom);
  self.addSubHeader(constants.COMPONENT_ID_TO, compTo);
  self.addSubHeader(constants.EXIT_CALL_TYPE_ORDER, exitOrder);
  self.addSubHeader(constants.EXIT_CALL_SUBTYPE_KEY, exitSubType);
  if (exitCallPositionVsLatestThreadAddId)
    self.addSubHeader(constants.THREAD_CALL_CHAIN_FOR_OUT_OF_PROCESS, exitCallPositionVsLatestThreadAddId)

  self.logger.debug("CorrelationHeader.build: correlation header generated: " + self.getStringHeader());
};