var constants = require('../constants'),
  httpService = require('../helpers/httpService').HttpService,
  Logger = require('../helpers/logger').Logger,
  Q = require('q');

function AgentConfigRequest(configOptions, agent, agentConfigResponse) {
  this.accountName = configOptions.accountName;
  this.accountAccessKey = configOptions.accountAccessKey;
  this.applicationName = configOptions.applicationName;
  this.tierName = configOptions.tierName;
  this.controllerHost = configOptions.controllerHost;
  this.controllerPort = configOptions.controllerPort;
  this.serverlessApiEndpoint = configOptions.serverlessApiEndpoint;
  this.functionName = configOptions.functionName;
  this.functionVersion = configOptions.functionVersion;
  this.invokedFunctionArn = configOptions.invokedFunctionArn;
  this.tracerVersion = configOptions.version;
  this.agent = agent;
  this.agentConfigResponse = agentConfigResponse;
  this.logger = Logger.getInstance();
  this.timeoutArr = [];
}

AgentConfigRequest.prototype.setFunctionDetails = function (fnName, fnVersion, invokedFnArn) {
  this.functionName = fnName;
  this.functionVersion = fnVersion;
  this.invokedFunctionArn = invokedFnArn;
  if (!this.tierName || !this.tierName.length) {
    this.tierName = this.functionName + '-' + this.functionVersion;
    httpService.setControllerTierName(this.tierName);
  }
}

AgentConfigRequest.prototype.getConfigUrl = function () {
  return this.serverlessApiEndpoint + constants.DEFAULT_CONFIG_URL_PATH;
}

AgentConfigRequest.prototype.sendRequest = function () {
  var self = this;
  var agentConfigReqBody = {
    'account_name': this.accountName,
    'application_name': this.applicationName,
    'tier_name': this.tierName,
    'controller_host': this.controllerHost,
    'controller_port': parseInt(this.controllerPort, 10),
    'function_name': this.functionName,
    'function_version': this.functionVersion,
    'invoked_function_arn': this.invokedFunctionArn,
    'language': 'node.js',
    'tracer_version': this.tracerVersion
  };
  var deferred = Q.defer();
  var headers = {};
  headers[constants.X_APPD_REQUEST_TYPE_HEADER] = constants.EVENT_TYPE_AGENT_CONFIG;
  httpService.post(self.getConfigUrl(), headers, agentConfigReqBody, constants.AGENT_CONFIG_READ_TIMEOUT_MILLIS)
    .then(function resolve(body) {
      if (body && body.error) {
        self.logger.debug('[Agent Config Request] Received 200 response with error body while sending the request to get agent config: ', body.error);
        deferred.reject(body.error);
      } else if (body)
        deferred.resolve(body);
    }, function reject(err) {
      self.logger.error('[Agent Config Request] Received error while sending the request to get agent config: ', err);
      deferred.reject(err);
    });
  return deferred.promise;
}

AgentConfigRequest.prototype.clearAllConfigTimeouts = function () {
  if (this.timeoutArr && this.timeoutArr.length) {
    var timeoutCount = this.timeoutArr.length;
    while (timeoutCount > 0) {
      clearTimeout(this.timeoutArr.pop());
      timeoutCount--;
    }
  }
}

// For the first invocation of the lambda function send the config request
// every 10sec till a success response is received uptil 60 secs
// After that no matter what start seding config request every 60 secs
AgentConfigRequest.prototype.sendConfigRequest = function (lambdaInvokedTimestamp) {
  if (this.timeoutArr && this.timeoutArr.length)
    this.timeoutArr.pop();

  if (!this.agent.lambdaFnRunning)
    return;

  var self = this;
  var logger = self.logger;
  var agent = self.agent;
  // For the first invocation

  // Make the call to logger
  if (self.agentConfigResponse && self.agentConfigResponse.getLastUpdateTime()
    && (Date.now() - self.agentConfigResponse.getLastUpdateTime()) < constants.AGENT_CONFIG_RETRY_TIMEOUT_MILLIS) {
    logger.info('Agent config response already exists for this function', self.agentConfigResponse.getApplicationId());
    var timeRemainingInConfigUpdate = constants.AGENT_CONFIG_RETRY_TIMEOUT_MILLIS - (Date.now() - self.agentConfigResponse.getLastUpdateTime());
    logger.debug('[AgentConfigRequest] Next config request will be sent in:', timeRemainingInConfigUpdate);
    self.setTimeout(function () {
      self.sendConfigRequest(lambdaInvokedTimestamp);
    }, timeRemainingInConfigUpdate)
  } else {
    self.sendRequest()
      .then(function resolve(configResponse) {
        logger.debug('Config Response is:', configResponse);
        self.agentConfigResponse.update(configResponse);
        agent.emit('configUpdated', self.agentConfigResponse);
        self.setTimeout(function () {
          self.sendConfigRequest(lambdaInvokedTimestamp);
        }, constants.AGENT_CONFIG_RETRY_TIMEOUT_MILLIS);
      }, function reject(err) {
        logger.debug('Config response error is:', err);
        if ((Date.now() - lambdaInvokedTimestamp) > constants.AGENT_CONFIG_RETRY_TIMEOUT_MILLIS) {
          self.setTimeout(function () {
            self.sendConfigRequest(lambdaInvokedTimestamp);
          }, constants.AGENT_CONFIG_RETRY_TIMEOUT_MILLIS);
        } else {
          self.setTimeout(function () {
            self.sendConfigRequest(lambdaInvokedTimestamp);
          }, constants.AGENT_CONFIG_CONNECT_TIMEOUT_MILLIS);
        }
      });
  }
}

AgentConfigRequest.prototype.setTimeout = function (cbFn, timeout) {
  if (!this.agent.lambdaFnRunning)
    return;
  else {
    var timeout = setTimeout(cbFn, timeout);
    this.timeoutArr.push(timeout);
  }
}

module.exports.AgentConfigRequest = AgentConfigRequest;