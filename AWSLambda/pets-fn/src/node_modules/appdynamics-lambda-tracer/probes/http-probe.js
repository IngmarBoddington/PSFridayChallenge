'use strict';

var url = require('url');
var HTTPParser = process.binding('http_parser').HTTPParser;
var Logger = require('../helpers/logger').Logger;
var constants = require('../constants');
var nodeVersionRegEx = /v([0-9]*).([0-9]*).([0-9]*)/;
var wrapperHelper = require('../helpers/wrapperService');

function HttpProbe(agent, profiler) {
  this.agent = agent;
  this.profiler = profiler;
  this.packages = ['http', 'https'];
}

exports.HttpProbe = HttpProbe;

HttpProbe.prototype.init = function () { };

HttpProbe.prototype.attach = function (obj, moduleName) {
  var self = this;
  var profiler = self.profiler;
  var logger = Logger.getInstance();

  if (moduleName == 'http') {
    var nodeMajorVersion = (process.version).match(nodeVersionRegEx);
    if (parseInt(nodeMajorVersion[1], 10) >= 8) {
      obj.get = function (options, cb) {
        var req = obj.request(options, cb);
        req.end();
        return req;
      };
    }
  }

  // support 0.11.x and further
  if (obj.globalAgent && obj.globalAgent.request) {
    obj = obj.globalAgent;
  }

  function clientCallback(locals) {
    var exitCall = locals.exitCall;
    if (exitCall) {
      var error = locals.error;
      if (!error && locals.res) {
        var httpStatusCode = ~~locals.res.statusCode;
        if ((httpStatusCode < 200) || (httpStatusCode >= 400)) {
          error = {
            message: "Error code " + httpStatusCode + " for URL " + locals.opts.hostname + ":" + locals.opts.port + locals.opts.path,
            stack: exitCall.stack,
            httpStatusCode: httpStatusCode
          };
        }
      }
      if (error) {
        profiler.reportExitCallError('HTTP Error', error.message, exitCall.backendId, error.httpStatusCode);
      }
      profiler.endExitCall(exitCall);
    }
  }

  if (obj.__appdynamicsProbeAttached__) return;
  obj.__appdynamicsProbeAttached__ = true;
  self.agent.on('destroy', function () {
    if (obj.__appdynamicsProbeAttached__) {
      delete obj.__appdynamicsProbeAttached__;
      wrapperHelper.release(obj.request);
    }
  })
  wrapperHelper.around(logger, obj, 'request', function (obj, args, locals) {
    var isRepeatForHttps = false;
    if (moduleName === 'https') {
      if (typeof (args[0]) === 'string') {
        args[0] = url.parse(args[0]);
      }
      args[0].__appdIsHttps = true;
    }
    self.setHttpDefaults(locals, args[0], moduleName);

    if (moduleName === 'http' && args[0].__appdIsHttps) {
      isRepeatForHttps = true;
    }

    // If args[0] host is http proxy url and method is CONNECT then ignore the call as it is
    // proxy tunneling call.
    if (args[0].method === 'CONNECT' && self.agent.getHttpProxyInfo() && self.agent.getHttpProxyInfo().host && self.agent.getHttpProxyInfo().host === args[0].host) {
      args[0].appdIgnore = true;
    }

    // Ignore internal HTTP calls, e.g. to Serverless API Endpoint
    // or http call made by other instrumented framework e.g Lambda Instrumentation
    if (!args[0].appdIgnore && !(args[0].headers && args[0].headers['appdIgnore']) && !isRepeatForHttps) {
      var host = locals.opts.hostname;
      var port = locals.opts.port;

      var supportedProperties = {
        'HOST': host,
        'PORT': port.toString()
      };

      locals.exitCall = profiler.startExitCall({
        exitType: 'HTTP',
        exitSubType: 'HTTP',
        identifyingProperties: supportedProperties
      });

      if (!locals.exitCall) return;

      Error.captureStackTrace(locals.exitCall);
      var dataConsumption = false, res;
      wrapperHelper.callback(logger, args, -1, function (obj, args) {
        res = args[0];
        // If there is no way to consume the data here, then close up the exit call loop and
        // release the httpParser's object httpParserMethod.
        // There are 3 ways to consume data from a readable stream according to the doc:
        // https://nodejs.org/dist/latest-v4.x/docs/api/stream.html#stream_class_stream_readable
        wrapperHelper.before(logger, res, ['on', 'addListener'], function (obj, args) {
          // workaround for end event
          if (!dataConsumption && args[0] === 'data') {
            dataConsumption = true;
          }
        }, false, false);

        wrapperHelper.before(logger, res, 'pipe', function () {
          dataConsumption = true;
        }, false, false);

        wrapperHelper.before(res, 'resume', function () {
          dataConsumption = true;
        }, false, false);
      }, function () {
        if (dataConsumption) return;
        var httpParser = res.socket.parser,
          kOnHeadersComplete = HTTPParser.kOnHeadersComplete | 0,
          httpParserMethod = kOnHeadersComplete ? kOnHeadersComplete : 'onHeadersComplete';
        wrapperHelper.release(httpParser[httpParserMethod]);
        locals.res = res;
        clientCallback(locals);
        res.socket.__appdynamicsCleanup = true;
      });
    }
  },
    function (obj, args, ret, locals) {
      var writeOnce = false, httpParser, httpParserMethod;

      if (!args[0].appdIgnore && (moduleName != 'http' || (moduleName === 'http' && !args[0].__appdIsHttps))) {
        wrapperHelper.before(logger, ret, ['on', 'addListener'], function (obj, args) {
          wrapperHelper.callback(logger, args, -1);
        }, false, false);

        wrapperHelper.before(logger, ret, ['write', 'end'], function (obj) {
          if (!writeOnce) {
            writeOnce = true;
            wrapperHelper.callback(ret, -1);
          } else {
            return;
          }

          if (locals.exitCall) {
            var correlationHeaderValue = profiler.getCorrelationHeaderValue(locals.exitCall);
            logger.debug('CorrelationHeaderValue is:', correlationHeaderValue);
            if (correlationHeaderValue && correlationHeaderValue.length)
              obj.setHeader(constants.APPDYNAMICS_TRANSACTION_CORRELATION_HEADER_KEY, correlationHeaderValue);
          }
        });

        ret.on('socket', function (socket) {
          // For v0.10.0 and below the httpParser has method named onHeadersComplete.
          // For v0.12.0 and above the httpParser has a constant int value for kOnHeadersComplete. The
          // callback for onHeaderComplete is attached as integer property on the parser and the
          // property is defined by the constant value of kOnHeadersComplete.
          httpParser = socket.parser;
          var kOnHeadersComplete = HTTPParser.kOnHeadersComplete | 0;
          httpParserMethod = kOnHeadersComplete ? kOnHeadersComplete : 'onHeadersComplete';

          var socketCloseHandler = function () {
            socket.removeListener('close', socketCloseHandler);
            if (socket.__appdynamicsCleanup) {
              return;
            }
            wrapperHelper.release(httpParser[httpParserMethod]);
            clientCallback(locals);
          };
          socket.on('close', socketCloseHandler);
          wrapperHelper.after(logger, httpParser, httpParserMethod, function (obj, args, ret) {
            var resp = httpParser.incoming;
            resp.on('end', function () {
              wrapperHelper.release(httpParser[httpParserMethod]);
              locals.res = resp;
              clientCallback(locals);
              socket.__appdynamicsCleanup = true;
              socket.removeListener('close', socketCloseHandler);
            });
            return ret;
          });
        });

        ret.on('error', function (error) {
          if (httpParser && httpParserMethod) {
            wrapperHelper.release(httpParser[httpParserMethod]);
          }
          locals.error = error;
          clientCallback(locals);
          if (ret.socket) {
            ret.socket.__appdynamicsCleanup = true;
          }
        });
      }
    });
};

HttpProbe.prototype.setHttpDefaults = function (locals, spec, protocol) {
  if (typeof (spec) === 'string') {
    locals.opts = url.parse(spec);
  }
  else {
    locals.opts = spec;
  }

  locals.opts.hostname = locals.opts.hostname || locals.opts.host || 'localhost';
  locals.opts.port = locals.opts.port || ((protocol === 'https') ? 443 : 80);
  locals.opts.path = locals.opts.path || '/';
};
