'use strict';

const util = require('util'),
  EventEmitter = require('events').EventEmitter;

const AgentConfigRequest = require('../config/agentConfigRequest').AgentConfigRequest,
  AgentConfigResponse = require('../config/agentConfigResponse').AgentConfigResponse,
  HttpService = require('../helpers/httpService').HttpService,
  EventsService = require('../services/events').EventsService,
  Profiler = require('./profiler').Profiler,
  TransactionReporter = require('../transaction/transactionReporter').TransactionReporter,
  TransactionRegistry = require('../transaction/transactionRegistry').TransactionRegistry,
  ExitCallReporter = require('../exitCall/exitCallReporter').ExitCallReporter,
  ExitCallRegistry = require('../exitCall/exitCallRegistry').ExitCallRegistry,
  wrapperService = require('../helpers/wrapperService'),
  Logger = require('../helpers/logger').Logger,
  Eum = require('../eum/eum').Eum;

// Assumption:
// options have all the necessory fields needed to create an agent config
function Tracer(options) {
  EventEmitter.call(this);
  this.initialize(options);
  this.logger = Logger.getInstance();
}

Tracer.prototype.initialize = function (options) {
  let self = this;
  let eumEnabled = process.env.APPDYNAMICS_ENABLE_EUM ? (process.env.APPDYNAMICS_ENABLE_EUM == true || ((process.env.APPDYNAMICS_ENABLE_EUM).toLowerCase() == 'true')) : false;
  this.agentConfigResponse = new AgentConfigResponse(null, this);
  this.agentConfigRequest = new AgentConfigRequest({
    controllerHost: options.controllerHost,
    controllerPort: options.controllerPort,
    accountName: options.accountName,
    accountAccessKey: options.accountAccessKey,
    tierName: options.tierName,
    applicationName: options.applicationName,
    serverlessApiEndpoint: options.serverlessApiEndpoint,
    version: options.version
  }, this, this.agentConfigResponse);

  HttpService(options.accountAccessKey,
    options.accountName,
    options.controllerHost,
    options.controllerPort,
    options.applicationName,
    options.tierName,
    options.version,
    options.proxyHost,
    options.proxyPort,
    options.proxyUser,
    options.proxyPassword,
    options.proxyPasswordFile,
    options.proxyCertificateFile);

  if (options.proxyHost && options.proxyPort)
    self.proxyInfo = {
      host: options.proxyHost,
      port: options.proxyPort
    };

  HttpService.init();

  wrapperService.cleanupSetup();
  wrapperService.setLogger();
  this.eventService = new EventsService(options.serverlessApiEndpoint, this);
  this.transactionRegistry = new TransactionRegistry(this);
  this.transactionReporter = new TransactionReporter(this, this.transactionRegistry, this.agentConfigResponse, this.eventService);
  this.exitCallRegistry = new ExitCallRegistry(this);
  this.exitCallReporter = new ExitCallReporter(this, this.exitCallRegistry, this.agentConfigResponse);
  this.profiler = new Profiler(this, this.eventService, this.exitCallRegistry, this.agentConfigRequest, this.agentConfigResponse);
  this.eum = new Eum(this.agentConfigResponse);
  this.eum.setEnabled(eumEnabled)

  this.transactionRegistry.init();
  this.transactionReporter.init();
  this.exitCallRegistry.init();
  this.exitCallReporter.init();
  this.agentInitialized = true;

  this.loadProbes();
  this.on('lambdaExecutionComplete', function () {
    self.agentConfigRequest.clearAllConfigTimeouts();
  });
};

Tracer.prototype.getHttpProxyInfo = function () {
  return this.proxyInfo;
}

Tracer.prototype.loadProbes = function () {
  let self = this;
  let probeCons = [];
  probeCons.push(require('../probes/http-probe').HttpProbe);
  probeCons.push(require('../probes/lambda-probe').LambdaProbe);
  let packageProbes = {};
  probeCons.forEach(function (ProbeCon) {
    let probe = new ProbeCon(self, self.profiler);
    probe.packages.forEach(function (pkg) {
      packageProbes[pkg] = probe;
    });
  });

  this.on('destroy', function () {
    wrapperService.release(module.__proto__.require);
  });
  wrapperService.after(this.logger, module.__proto__, 'require', function (obj, args, ret) {
    let probe = packageProbes[args[0]];
    if (probe) {
      return probe.attach(ret, args[0]);
    }
  });

  // Trying to preattaching probes.
  for (let name in packageProbes) {
    try {
      if (require.main) {
        require.main.require(name);
        this.logger.debug('found ' + name + ' module');
      }
    }
    catch (err) {
      // ignore exceptions
    }
  }
}

Tracer.prototype.mainModule = function (appModule) {
  let ModuleWrapper = require('../moduleWrapper').ModuleWrapper;
  new ModuleWrapper(this, this.logger, this.eum).attach(appModule, this.agentConfigRequest);
}

Tracer.prototype.createTransaction = function (event, context) {
  return this.profiler.startTransaction(event, context);
}

Tracer.prototype.getCurrentTransaction = function () {
  return this.profiler.getCurrentTransaction();
}

Tracer.prototype.stopTransaction = function () {
  return this.profiler.stopTransaction();
}

Tracer.prototype.reportError = function (error) {
  return this.profiler.reportError(error);
}

Tracer.prototype.startExitCall = function (exitCallInfo) {
  return this.profiler.startExitCall(exitCallInfo);
}

Tracer.prototype.endExitCall = function (exitCall) {
  return this.profiler.endExitCall(exitCall);
}

Tracer.prototype.createCorrelationInfo = function (exitCall) {
  return this.profiler.getCorrelationHeaderValue(exitCall);
}

Tracer.prototype.reportExitCallError = function (exitCall, errorName, errorMessage) {
  if (!exitCall) {
    this.logger.error('Cannot report exit call error as exit call object is missing.');
    return;
  }
  if (exitCall && exitCall.backendId == undefined) {
    this.logger.error('Cannot report exit call error as exit call object is missing backend id.');
    return;
  }
  if (!errorName || !errorMessage) {
    this.logger.error('Cannot report exit call error as both error name and error message need to be sent.');
    return;
  }
  return this.profiler.reportExitCallError(errorName, errorMessage, exitCall.backendId);
}

Tracer.prototype.getEumMetadata = function (transaction) {
  if (!transaction) {
    this.logger.error('Cannot get the eum metadata as transaction is missing.');
    return;
  }
  if (this.eum.enabled)
    return this.profiler.getEumMetadata(transaction, this.eum);
  this.logger.info('Cannot get the eum metadata. Enable the environment variable APPDYNAMICS_ENABLE_EUM');
  return;
}

util.inherits(Tracer, EventEmitter);

module.exports.Tracer = Tracer;