'use strict';

var Logger = require('../helpers/logger').Logger;
var wrapperHelper = require('../helpers/wrapperService');
var constants = require('../constants');

function LambdaProbe(agent, profiler) {
  this.agent = agent;
  this.profiler = profiler;
  this.packages = ['aws-sdk'];
}
exports.LambdaProbe = LambdaProbe;

LambdaProbe.prototype.attach = function (obj) {
  var self = this;
  var profiler = self.profiler;
  var logger = Logger.getInstance();

  if (obj.__appdynamicsProbeAttached__) return;
  obj.__appdynamicsProbeAttached__ = true;
  self.agent.on('destroy', function () {
    if (obj.__appdynamicsProbeAttached__) {
      delete obj.__appdynamicsProbeAttached__;
      wrapperHelper.release(obj.Lambda);
    }
  });

  function endExitCall(locals) {
    if (locals.exitCall && !locals.exitCall.ended) {
      if (locals.error)
        profiler.reportExitCallError('LAMBDA Error', locals.error, locals.exitCall.backendId);
      profiler.endExitCall(locals.exitCall);
      locals.exitCall.ended = true;
    }
  }

  function addCorrelationHeader(lambdaEventString, exitCall) {
    try {
      var eventData = JSON.parse(lambdaEventString);
      if (!eventData[constants.APPDYNAMICS_TRANSACTION_CORRELATION_HEADER_KEY]) {
        var correlationHeaderValue = profiler.getCorrelationHeaderValue(exitCall);
        logger.debug('CorrelationHeaderValue is:', correlationHeaderValue);
        if (correlationHeaderValue && correlationHeaderValue.length)
          eventData[constants.APPDYNAMICS_TRANSACTION_CORRELATION_HEADER_KEY] = correlationHeaderValue;
      }
      return JSON.stringify(eventData);
    } catch (e) {
      logger.error('Error in adding the correlation header to lambda invokation.', e);
      return;
    }
  }

  wrapperHelper.after(logger, obj, 'Request', function (obj, args, ret) {
    // Make sure to not instrument the http request made for this lambda invocation
    if (ret.service && ret.service.api && (ret.service.api.serviceId === 'Lambda')) {
      ret.on('build', function () {
        if (ret.httpRequest && ret.httpRequest.headers)
          ret.httpRequest.headers['appdIgnore'] = true;
      });
    }
  });
  wrapperHelper.after(logger, obj, 'Lambda', function (obj, args, ret) {
    var lambdaInst = ret;

    wrapperHelper.around(logger, lambdaInst, ['invoke', 'invokeAsync'], function (obj, args, locals) {
      // Start the exit call
      locals.exitCall = profiler.startExitCall({
        exitType: 'CUSTOM',
        exitSubType: 'CUSTOM',
        identifyingProperties: {
          'DESTINATION_TYPE': 'LAMBDA',
          'DESTINATION': args[0]['FunctionName']
        }
      });
      // Add the correlation header info in the `event` object of invocation
      var modifiedEventDataStr;
      if (args[0]['InvokeArgs']) {
        modifiedEventDataStr = addCorrelationHeader(args[0]['InvokeArgs'], locals.exitCall);
        args[0]['InvokeArgs'] = modifiedEventDataStr ? modifiedEventDataStr : args[0]['InvokeArgs'];
      } else if (args[0]['Payload']) {
        modifiedEventDataStr = addCorrelationHeader(args[0]['Payload'], locals.exitCall);
        args[0]['Payload'] = modifiedEventDataStr ? modifiedEventDataStr : args[0]['Payload'];
      } else {
        modifiedEventDataStr = addCorrelationHeader('{}', locals.exitCall);
        if (modifiedEventDataStr) {
          if (locals.methodName === 'invoke')
            args[0]['Payload'] = modifiedEventDataStr;
          if (locals.methodName === 'invokeAsync')
            args[0]['InvokeArgs'] = modifiedEventDataStr;
        }
      }
    }, function (obj, args, ret, locals) {
      //  Add handler for some events on the returned AWS.Request object:
      //   In handler for success, error and complete event end the exit call.
      ret.on('success', function (response) {
        if (response.data) {
          if (response.data.FunctionError) {
            if (response.data.Payload) {
              try {
                var responsePayload = JSON.parse(response.data.Payload);
                locals.error = responsePayload.errorMessage;
              } catch (e) {
                logger.error('Error in parsing the lambda response payload');
              }
            }
            if (!locals.error)
              locals.error = 'Lambda function invocation has an unknown error.'
          }
          endExitCall(locals);
        }
      })
      ret.on('error', function (response) {
        if (response.error) {
          locals.error = fetchError(response.error);
          endExitCall(locals);
        }
      });
      ret.on('complete', function (response) {
        if (response.error)
          locals.error = fetchError(response.error);
        endExitCall(locals);
      });
    })
  })
};

function fetchError(input) {
  if (input instanceof Error)
    return input.message;
  if ((typeof input === 'object') && input.message)
    return input.message;
  if ((typeof input === 'string'))
    return input;
  else
    return 'Unknown Lambda Error';
}
