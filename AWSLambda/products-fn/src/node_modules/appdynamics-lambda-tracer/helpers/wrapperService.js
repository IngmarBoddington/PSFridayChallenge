/*
Copyright (c) AppDynamics, Inc., and its affiliates
2019
All Rights Reserved
 */
'use strict';

var EventEmitter = require('events').EventEmitter;
var Logger = require('../helpers/logger').Logger;
var logger;

var Locals = function () {
  this.time = undefined;
  this.stackTrace = undefined;
  this.params = undefined;
  this.opts = undefined;
  this.group = undefined;
  this.req = undefined;
  this.res = undefined;
  this.error = undefined;
  this.transaction = undefined;
  this.exitCall = undefined;
};

function setLogger() {
  logger = Logger.getInstance();
}

function cleanupSetup() {
  // removeListener compairs objects, so the original callback
  // should be passed instead of the proxy
  before(logger, EventEmitter.prototype, 'removeListener', function (obj, args) {
    if (args.length > 1 && args[1] && args[1].__appdynamicsProxy__) {
      args[1] = args[1].__appdynamicsProxy__;
    } else {
      // Try to match the callback function intended to be removed for
      // the event with all the probed callbacks attached for that event
      // on the object
      var eventCbList = obj._events[args[0]];
      if ((typeof eventCbList === 'function') && eventCbList.__appdynamicsProxy__ && eventCbList.__appdynamicsProxy__ === args[1]) {
        eventCbList = eventCbList.__appdynamicsProxy__;
        obj._events[args[0]] = eventCbList;
      }
      if (eventCbList && eventCbList.length) {
        for (var i = 0; i < eventCbList.length; i++) {
          if (eventCbList[i] && eventCbList[i].__appdynamicsProxy__ && (eventCbList[i].__appdynamicsProxy__ === args[1]))
            eventCbList[i] = eventCbList[i].__appdynamicsProxy__;
        }
      }
    }
  });
}


function release(proxied) {
  var info = proxied.__appdynamicsProxyInfo__;

  if (!info) return;
  info.obj[info.meth] = info.orig;
}

function isPromiseSupported() {
  if (parseInt(process.versions.node.split('.')[0], 10) === 0 && parseInt(process.versions.node.split('.')[1], 10) < 12)
    return false;
  return true;
}

/**
 * Helper function that chains promiseHook after returnVal if returnVal is a promise. 
 */
function promise(returnVal, promiseHook, obj, methodArgs, locals) {
  // For unsupported node versions return.
  if (!isPromiseSupported())
    return;
  // A Promise is always 'thenable'.
  // "thenable" is an object or function that defines a then method.
  // Here is thread, with a discussion on how to determine if an Object is a Promise
  // https://stackoverflow.com/questions/27746304/how-do-i-tell-if-an-object-is-a-promise
  if (!returnVal || typeof (returnVal.then) !== 'function')
    return;

  // For Promises
  return returnVal.then(function resolve(data) {
    let promiseHookRet = promiseHook(obj, methodArgs, {
      __appdynamicsIsPromiseResult__: true,
      error: null,
      data: data
    }, locals);

    // If promiseHook returns a promise, chain it.
    if (promiseHookRet && typeof (promiseHookRet.then) === 'function') {
      return promiseHookRet.then(() => {
        return data;
      }).catch(promiseHookErr => {
        //TODO: is it okay to use the logger instance directly or should I pass this as one of the arguments?
        logger.error(promiseHookErr);
        return data;
      });
    }

    return data;
  }).catch(function (err) {
    let promiseHookRet = promiseHook(obj, methodArgs, {
      __appdynamicsIsPromiseResult__: true,
      error: err || 'AppDPromiseError', // Put the default value for the error, so that check on error property passes
      data: null
    }, locals);

    // If promiseHook returns a promise, chain it.
    if (promiseHookRet && typeof (promiseHookRet.then) === 'function') {
      let promiseHookSucceeded = false;

      return promiseHookRet.then(() => {
        promiseHookSucceeded = true;
        return Promise.reject(err);
      }).catch(promiseHookErr => {
        // This check is needed so that we don't extraneously log the error thrown in the previous then block
        if (!promiseHookSucceeded) {
          logger.error(promiseHookErr);
        }
        return Promise.reject(err);
      });
    }
    return Promise.reject(err);
  });
};

function around(logger, obj, meths, hookBefore, hookAfter) {
  if (!obj) return false;

  if (!Array.isArray(meths)) meths = [meths];

  meths.forEach(function (meth) {
    var orig = obj[meth];
    if (!orig) return;

    obj[meth] = function () {
      try {
        var locals = new Locals();
        locals.methodName = meth;
        try {
          hookBefore(this, arguments, locals);
        }
        catch (e) {
          logger.error(e);
        }

        try {
          var ret = callOrigFunction(this, orig, obj[meth], arguments);
        } catch (e) {
          var ret = {
            "error": e,
            "isLambdaError": true
          };
        }

        var promiseRet = promise(ret, hookAfter, this, arguments, locals);
        if (promiseRet) {
          return promiseRet;
        }

        var hookRet;
        try {
          hookRet = hookAfter(this, arguments, ret, locals);
        }
        catch (e) {
          logger.error(e);
        }

        if (hookRet) {
          return hookRet;
        }

        if (ret) {
          if (ret.error && ret.isLambdaError) {
            throw ret
          }
          return ret;
        }
      } catch (e) {
        logger.error(e);
        //If the originating lambda threw an error, we still need to make the lambda throw an error instead of swallowing it in the around hook.
        if (e.isLambdaError && e.error) {
          logger.warn("Error occurred in lambda. This will cause the Node.js process to exit and hence Appdynamics will not able to report metrics.");
          throw e.error;
        }
      }
    };

    obj[meth].__appdynamicsProxyInfo__ = {
      obj: obj,
      meth: meth,
      orig: orig
    };
  });
};

function before(logger, obj, meths, hook, isCallbackHook, copyAllProps) {
  if (!obj) return false;
  if (!Array.isArray(meths)) meths = [meths];
  meths.forEach(function (meth) {
    var orig = obj[meth];
    if (!orig) return;

    var beforeExecLogic = function () {
      try {
        if (isCallbackHook) {
          var selfProxy = this;
          // the hook code should contain try/catch
          hook(this, arguments, function () {
            return orig.apply(selfProxy, arguments);
          });
        }
        else {
          try {
            hook(this, arguments);
          }
          catch (e) {
            logger.error(e);
          }
          var retValue = callOrigFunction(this, orig, obj[meth], arguments);
          return retValue;
        }
      } catch (e) {
        logger.error(e);
      }
    };

    obj[meth] = getArityFunction(orig.length, beforeExecLogic);

    if (copyAllProps) copyObjectProps(orig, obj[meth]);

    obj[meth].__appdynamicsProxyInfo__ = {
      obj: obj,
      meth: meth,
      orig: orig
    };
  });
}

function after(logger, obj, meths, hook, copyAllProps) {
  if (!obj) return false;

  if (!Array.isArray(meths)) meths = [meths];

  meths.forEach(function (meth) {
    var orig = obj[meth];
    if (!orig) return;
    var afterExecLogic = function () {
      try {
        var ret = callOrigFunction(this, orig, obj[meth], arguments);
        var hookRet;
        try {
          hookRet = hook(this, arguments, ret);
        }
        catch (e) {
          logger.error(e);
        }
        return hookRet || ret;
      } catch (e) {
        logger.error(e);
      }
    };
    obj[meth] = getArityFunction(orig.length, afterExecLogic);

    if (copyAllProps) copyObjectProps(orig, obj[meth]);

    obj[meth].__appdynamicsProxyInfo__ = {
      obj: obj,
      meth: meth,
      orig: orig
    };
  });
};
/**
 * Similar wrapper as callback(logger, args, pos, hookBefore, hookAfter) however this uses 
 * promises to chain together the hooks. This fixes the bug where on cold start if an error is passed
 * on to the lambda handler callback, the container is frozen before the cold start events are flushed.
 */
function callbackPromiseChain(logger, args, pos, hookBefore, hookAfter) {
  if (!args) return false;

  if (args.length <= pos) return false;
  if (pos === -1) pos = args.length - 1;

  // orig is the callback function that is passed to handler
  let orig = (typeof args[pos] === 'function') ? args[pos] : undefined;
  if (!orig) return false;

  args[pos] = function appd_proxy() {
    let callbackThis = this;
    let callbackArgs = arguments;
    let hbPromise = new Promise((resolve, reject) => {
      let hbReturnsPromise = false;
      if (hookBefore) {
        try {
          let hookBeforeRet = hookBefore(callbackThis, callbackArgs);

          // Check that hookBefore returns a promise
          if (hookBeforeRet && typeof (hookBeforeRet.then) === 'function') {
            hbReturnsPromise = true;
            hookBeforeRet.then(() => {
              resolve();
            }).catch(hookBeforeErr => {
              logger.error(hookBeforeErr);
              resolve();
            });
          }

        } catch (e) {
          logger.error(e);
        }
      }

      if (!hbReturnsPromise) {
        resolve();
      }
    }).then(() => {
      return Promise.resolve(orig.apply(callbackThis, callbackArgs));
    }).then(origRet => {
      if (hookAfter) {
        try {
          let hookAfterRet = hookAfter(callbackThis, callbackArgs, origRet);
          
          if (hookAfterRet && typeof (hookAfterRet.then) === 'function') {
            return hookAfterRet.then(() => {
              return origRet;
            }).catch(hookAfterErr => {
              logger.error(hookAfterErr);
              return origRet;
            });
          }
        } catch (e) {
          logger.error(e);
        }
      }
      return origRet;
    });

    return hbPromise;
  };

  // this is needed for removeListener
  args[pos].__appdynamicsProxy__ = orig;

  return true;
}

/**
 * Wrapper for a callback that is passed to a function, can add hooks before and after
 * the callback.
 */
function callback(logger, args, pos, hookBefore, hookAfter) {
  if (!args) return false;

  if (args.length <= pos) return false;
  if (pos === -1) pos = args.length - 1;

  var orig = (typeof args[pos] === 'function') ? args[pos] : undefined;
  if (!orig) return false;

  args[pos] = function appd_proxy() {
    try {
      if (hookBefore) {
        try {
          hookBefore(this, arguments);
        }
        catch (e) {
          logger.error(e);
        }
      }

      var ret = orig.apply(this, arguments);

      if (hookAfter) {
        try {
          hookAfter(this, arguments, ret);
        }
        catch (e) {
          logger.error(e);
        }
      }
      return ret;
    } catch (e) {
      logger.error(e);
    }
  };

  // this is needed for removeListener
  args[pos].__appdynamicsProxy__ = orig;

  return true;
};

function getErrorObject(args) {
  if (args && args.length > 0 && args[0]) {
    if (typeof (args[0]) === 'object' || typeof (args[0]) === 'string') {
      return args[0];
    }
    else {
      return 'unspecified';
    }
  }

  return undefined;
};

function callOrigFunction(context, origFn, modifiedFn, fnInvokeArgs) {
  if (context && context.constructor && context.constructor === modifiedFn)
    return callConstructorFunction(origFn, fnInvokeArgs);
  else
    return origFn.apply(context, fnInvokeArgs);
}

function copyObjectProps(source, destination) {
  var methodProps = Object.getOwnPropertyNames(source);

  for (var i = 0; i < methodProps.length; i++) {
    if (Object.getOwnPropertyDescriptor(source, methodProps[i]).writable) {
      destination[methodProps[i]] = source[methodProps[i]];
    }
  }
}

/* istanbul ignore next */
function callConstructorFunction(functionLogic, fnArgs) {
  switch (fnArgs.length) {
    case 0:
      return new functionLogic();
    case 1:
      return new functionLogic(fnArgs[0]);
    case 2:
      return new functionLogic(fnArgs[0], fnArgs[1]);
    case 3:
      return new functionLogic(fnArgs[0], fnArgs[1], fnArgs[2]);
    case 4:
      return new functionLogic(fnArgs[0], fnArgs[1], fnArgs[2], fnArgs[3]);
    case 5:
      return new functionLogic(fnArgs[0], fnArgs[1], fnArgs[2], fnArgs[3], fnArgs[4]);
    case 6:
      return new functionLogic(fnArgs[0], fnArgs[1], fnArgs[2], fnArgs[3], fnArgs[4], fnArgs[5]);
    case 7:
      return new functionLogic(fnArgs[0], fnArgs[1], fnArgs[2], fnArgs[3], fnArgs[4], fnArgs[5], fnArgs[6]);
    case 8:
      return new functionLogic(fnArgs[0], fnArgs[1], fnArgs[2], fnArgs[3], fnArgs[4], fnArgs[5], fnArgs[6], fnArgs[7]);
    case 9:
      return new functionLogic(fnArgs[0], fnArgs[1], fnArgs[2], fnArgs[3], fnArgs[4], fnArgs[5], fnArgs[6], fnArgs[7], fnArgs[8]);
    case 10:
      return new functionLogic(fnArgs[0], fnArgs[1], fnArgs[2], fnArgs[3], fnArgs[4], fnArgs[5], fnArgs[6], fnArgs[7], fnArgs[8], fnArgs[9]);
    default:
      logger.warn('Experienced a high arity function with arity of ', fnArgs.length);
      return new functionLogic(fnArgs);
  }
}

/* istanbul ignore next */
function getArityFunction(arity, functionLogic) {
  var returnFunc;
  switch (arity) {
    case 0:
      returnFunc = function () {
        return functionLogic.apply(this, arguments);
      };
      break;
    case 1:
      returnFunc = function (a) {
        return functionLogic.apply(this, arguments);
      };
      break;
    case 2:
      returnFunc = function (a, b) {
        return functionLogic.apply(this, arguments);
      };
      break;
    case 3:
      returnFunc = function (a, b, c) {
        return functionLogic.apply(this, arguments);
      };
      break;
    case 4:
      returnFunc = function (a, b, c, d) {
        return functionLogic.apply(this, arguments);
      };
      break;
    case 5:
      returnFunc = function (a, b, c, d, e) {
        return functionLogic.apply(this, arguments);
      };
      break;
    case 6:
      returnFunc = function (a, b, c, d, e, f) {
        return functionLogic.apply(this, arguments);
      };
      break;
    case 7:
      returnFunc = function (a, b, c, d, e, f, g) {
        return functionLogic.apply(this, arguments);
      };
      break;
    case 8:
      returnFunc = function (a, b, c, d, e, f, g, h) {
        return functionLogic.apply(this, arguments);
      };
      break;
    case 9:
      returnFunc = function (a, b, c, d, e, f, g, h, i) {
        return functionLogic.apply(this, arguments);
      };
      break;
    case 10:
      returnFunc = function (a, b, c, d, e, f, g, h, i, j) {
        return functionLogic.apply(this, arguments);
      };
      break;
    default:
      logger.error('Experienced a high arity function with arity of ', arity);
      returnFunc = function () {
        return functionLogic.apply(this, arguments);
      };
      break;
  }
  return returnFunc;
};

module.exports = {
  cleanupSetup: cleanupSetup,
  setLogger: setLogger,
  release: release,
  isPromiseSupported: isPromiseSupported,
  promise: promise,
  around: around,
  before: before,
  after: after,
  callback: callback,
  callbackPromiseChain: callbackPromiseChain,
  getErrorObject: getErrorObject
}

