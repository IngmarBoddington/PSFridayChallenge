// Http Service makes http/https calls
var request = require('request'),
  crypto = require('crypto'),
  constants = require('../constants'),
  Q = require('q');

var Logger = require('../helpers/logger').Logger;
var utility = require('./utility');

var controllerAccessKey,
  controllerAccountName,
  controllerHost,
  controllerPort,
  controllerApplicationName,
  controllerTierName,
  tracerVersion,
  logger,
  reqHeaders = {};

function HttpService(ctAccessKey, ctAccountName,
  ctHost, ctPort, ctApplicationName,
  ctTierName, tracerVr, proxyHost, proxyPort,
  proxyUser, proxyPassword, proxyPasswordFile,
  proxyCertificateFile) {
  logger = Logger.getInstance();
  HttpService.request = request;
  HttpService.setControllerAccessKey(ctAccessKey);
  HttpService.setControllerAccoutnName(ctAccountName);
  HttpService.setControllerHost(ctHost);
  HttpService.setControllerPort(ctPort);
  HttpService.setControllerAppName(ctApplicationName);
  HttpService.setControllerTierName(ctTierName);
  HttpService.setTracerVersion(tracerVr);
  HttpService.setProxyDetails(proxyHost, proxyPort, proxyUser, proxyPassword, proxyPasswordFile, proxyCertificateFile);
}

HttpService.setTracerVersion = function (tracerVr) {
  tracerVersion = tracerVr;
  HttpService.init();
}

HttpService.getTracerVersion = function () {
  return tracerVersion;
}

HttpService.setControllerTierName = function (ctTierName) {
  controllerTierName = ctTierName;
  HttpService.init();
}

HttpService.getControllerTierName = function () {
  return controllerTierName;
}

HttpService.setControllerAppName = function (ctApplicationName) {
  controllerApplicationName = ctApplicationName;
  HttpService.init();
}

HttpService.getControllerAppName = function () {
  return controllerApplicationName;
}

HttpService.setControllerPort = function (ctPort) {
  controllerPort = ctPort;
  HttpService.init();
}

HttpService.getControllerPort = function () {
  return controllerPort;
}

HttpService.setControllerHost = function (ctHost) {
  controllerHost = ctHost;
  HttpService.init();
}

HttpService.getControllerHost = function () {
  return controllerHost;
}

HttpService.setControllerAccessKey = function (ctAccessKey) {
  controllerAccessKey = ctAccessKey
  HttpService.init();
}

HttpService.getControllerAccessKey = function () {
  return controllerAccessKey;
}

HttpService.setControllerAccoutnName = function (ctAccountName) {
  controllerAccountName = ctAccountName;
  HttpService.init();
}

HttpService.getControllerAccountName = function () {
  return controllerAccountName;
}

HttpService.setProxyDetails = function (proxyHost, proxyPort, proxyUser, proxyPassword, proxyPasswordFile, proxyCertificateFile) {
  // Setup proxy defaults
  if (proxyHost && proxyPort) {
    var user = proxyUser,
      password = proxyPassword,
      passwordFilePath = proxyPasswordFile,
      proxyUrl = proxyHost,
      proxyPort = proxyPort,
      proxyUrlFullPath = 'http://' + proxyUrl + ':' + proxyPort,
      caCertFilePath = proxyCertificateFile,
      proxySettings = {},
      caCertFileContents;

    if (passwordFilePath) {
      var contents = utility.readFile(passwordFilePath, logger);
      if (contents)
        password = contents; // Prefer password store in file over environment variable
    }

    if (user && password) {
      proxyUrlFullPath = 'http://' + user + ':' + password + '@' + proxyUrl + ':' + proxyPort;
    }

    if (caCertFilePath) {
      caCertFileContents = utility.readFile(caCertFilePath, logger);
      if (!caCertFileContents) {
        logger.error('[HTTP Service]: Failed in reading the ca cert file and could not do the proxy setup.');
        return;
      }

      proxySettings = {
        proxy: proxyUrlFullPath,
        ca: caCertFileContents
      }

      HttpService.request = HttpService.request.defaults({ proxy: proxyUrlFullPath, ca: caCertFileContents });
    } else {
      proxySettings = {
        proxy: proxyUrlFullPath
      };
      HttpService.request = HttpService.request.defaults({ proxy: proxyUrlFullPath });
    }
    logger.debug('[HTTP Service]: proxy settings are ', proxySettings);
  }
  if (proxyHost && !proxyPort) {
    logger.error('[HTTP Service]: Missing required configuration proxyPort. proxyPort can be set either through options or environment variable APPDYNAMICS_HTTP_PROXY_PORT');
  }
  if (proxyPort && !proxyHost) {
    logger.error('[HTTP Service]: Missing required configuration proxyHost. proxyHost can be set either through options or environment variable APPDYNAMICS_HTTP_PROXY_HOST');
  }
  HttpService.init();
}

HttpService.init = function () {
  reqHeaders[constants.X_APPD_API_KEY_HEADER] = HttpService.calculateAPIKey();
  reqHeaders[constants.X_APPD_ROUTING_KEY_HEADER] = HttpService.generateRoutingKey();
}

HttpService.calculateAPIKey = function () {
  var payload = controllerAccessKey + '-' + controllerAccountName;
  var hash = crypto.createHash('sha256');
  return hash.update(payload).digest('hex');
}

HttpService.generateRoutingKey = function () {
  var routingKeys = [controllerHost,
    controllerPort,
    controllerAccountName,
    controllerApplicationName,
    controllerTierName,
    tracerVersion];
  var payload = routingKeys.join('|');
  var hash = crypto.createHash('sha1');
  return hash.update(payload).digest('hex');
}

HttpService.reset = function () {
  controllerAccessKey = undefined;
  controllerAccountName = undefined;
  controllerHost = undefined;
  controllerPort = undefined;
  controllerApplicationName = undefined;
  controllerTierName = undefined;
  tracerVersion = undefined;
}

HttpService.post = function (url, headers, body, connectionTimeout) {
  var deferred = Q.defer();
  if (headers) {
    headers = Object.assign(headers, reqHeaders);
  }
  var options = {
    url: url,
    method: 'POST',
    json: true,
    headers: headers ? headers : reqHeaders,
    body: body,
    appdIgnore: true
  };
  if (logger)
    logger.debug('[HTTP Service] Options are:', options);
  if (connectionTimeout)
    options['timeout'] = connectionTimeout;

  HttpService.request(options, function (error, response, body) {
    if (error)
      deferred.reject(error);
    else if (response.statusCode == 200 || response.statusCode == 201)
      deferred.resolve(body);
    else if (response.statusCode == 403)
      deferred.reject('Received response status code: 403 - Appdynamics Node.js Tracer failed to authenticate. Verify the \'APPDYNAMICS_ACCOUNT_NAME\', \'APPDYNAMICS_AGENT_ACCOUNT_ACCESS_KEY\', and \'APPDYNAMICS_SERVERLESS_API_ENDPOINT\' environment variables.');
    else
      deferred.reject('Received response status code:' + response.statusCode);
  });
  return deferred.promise;
};

HttpService.get = function (url, headers, connectionTimeout) {
  var deferred = Q.defer();
  if (headers) {
    headers = Object.assign(headers, reqHeaders);
  }
  var options = {
    url: url,
    headers: headers ? headers : reqHeaders,
    appdIgnore: true
  };
  if (logger)
    logger.debug('[HTTP Service] Options are:', options);
  if (connectionTimeout)
    options['timeout'] = connectionTimeout;
  HttpService.request(options, function (error, response, body) {
    if (error)
      deferred.reject(error);
    else if (response.statusCode == 200 || response.statusCode == 201)
      deferred.resolve(body);
    else if (response.statusCode == 403)
      deferred.reject('Received response status code: 403 - Appdynamics Node.js Tracer failed to authenticate. Verify the \'APPDYNAMICS_ACCOUNT_NAME\', \'APPDYNAMICS_AGENT_ACCOUNT_ACCESS_KEY\', and \'APPDYNAMICS_SERVERLESS_API_ENDPOINT\' environment variables.');
    else
      deferred.reject('Received response status code:' + response.statusCode);
  });
  return deferred.promise;
};

module.exports.HttpService = HttpService;

